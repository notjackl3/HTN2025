{"ast":null,"code":"var _jsxFileName = \"/Users/notjackl3/Desktop/HTN2025/frontend/src/components/CameraView.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport { seriousModeDetection, funModeDetection, completeQuest, placeBet, resolveBet } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CameraView = ({\n  mode,\n  onQuestComplete,\n  onBetPlaced\n}) => {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [stream, setStream] = useState(null);\n  const [isDetecting, setIsDetecting] = useState(false);\n  const [detectionResults, setDetectionResults] = useState(null);\n  const [error, setError] = useState(null);\n  const [boundingBoxes, setBoundingBoxes] = useState([]);\n  const [isRealTimeDetection, setIsRealTimeDetection] = useState(true);\n  const [detectionInterval, setDetectionInterval] = useState(null);\n  useEffect(() => {\n    startCamera();\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (detectionInterval) {\n        clearInterval(detectionInterval);\n      }\n    };\n  }, []);\n\n  // Redraw bounding boxes when video loads or resizes\n  useEffect(() => {\n    const video = videoRef.current;\n    if (video) {\n      const handleLoadedMetadata = () => {\n        if (detectionResults !== null && detectionResults !== void 0 && detectionResults.detections) {\n          setTimeout(() => drawBoundingBoxes(), 100);\n        }\n      };\n      video.addEventListener('loadedmetadata', handleLoadedMetadata);\n      return () => video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n    }\n  }, [detectionResults]);\n\n  // Real-time detection effect\n  useEffect(() => {\n    if (isRealTimeDetection && stream) {\n      const interval = setInterval(() => {\n        performRealTimeDetection();\n      }, 500); // Detect every 500ms for smoother real-time experience\n\n      setDetectionInterval(interval);\n      return () => {\n        if (interval) {\n          clearInterval(interval);\n        }\n      };\n    } else if (detectionInterval) {\n      clearInterval(detectionInterval);\n      setDetectionInterval(null);\n    }\n  }, [isRealTimeDetection, stream]);\n  const startCamera = async () => {\n    try {\n      const mediaStream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          width: {\n            ideal: 1280\n          },\n          height: {\n            ideal: 720\n          },\n          facingMode: 'user'\n        }\n      });\n      setStream(mediaStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = mediaStream;\n        // Start real-time detection immediately\n        setIsRealTimeDetection(true);\n      }\n    } catch (err) {\n      setError('Camera access denied. Please allow camera access to use this feature.');\n      console.error('Camera error:', err);\n    }\n  };\n  const capturePhoto = () => {\n    if (!videoRef.current || !canvasRef.current) return null;\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    context.drawImage(video, 0, 0);\n    return new Promise(resolve => {\n      canvas.toBlob(resolve, 'image/jpeg', 0.8);\n    });\n  };\n  const performRealTimeDetection = async () => {\n    if (!videoRef.current || isDetecting) return;\n    try {\n      var _response$detections;\n      // Create a canvas to capture video frame\n      const video = videoRef.current;\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n\n      // Set canvas size to match video\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n\n      // Draw current video frame to canvas\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // Convert canvas to blob\n      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));\n      if (!blob) return;\n      const formData = new FormData();\n      formData.append('file', blob, 'frame.jpg');\n      let response;\n      if (mode === 'serious') {\n        response = await seriousModeDetection(formData);\n      } else {\n        response = await funModeDetection(formData);\n      }\n\n      // Filter detections with 80%+ confidence\n      const highConfidenceDetections = ((_response$detections = response.detections) === null || _response$detections === void 0 ? void 0 : _response$detections.filter(detection => detection.confidence >= 0.8)) || [];\n      if (highConfidenceDetections.length > 0) {\n        setBoundingBoxes(highConfidenceDetections);\n        setTimeout(() => drawBoundingBoxes(), 50);\n      } else {\n        // Clear boxes if no high confidence detections\n        setBoundingBoxes([]);\n        clearBoundingBoxes();\n      }\n    } catch (err) {\n      console.error('Real-time detection error:', err);\n    }\n  };\n  const clearBoundingBoxes = () => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  };\n  const drawBoundingBoxes = () => {\n    if (!videoRef.current || !boundingBoxes.length) return;\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n\n    // Set canvas size to match video\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    // Clear previous drawings\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw bounding boxes\n    boundingBoxes.forEach((detection, index) => {\n      const {\n        x,\n        y,\n        width,\n        height,\n        label,\n        confidence\n      } = detection;\n\n      // Calculate scale factors\n      const scaleX = video.videoWidth / video.clientWidth;\n      const scaleY = video.videoHeight / video.clientHeight;\n      const scaledX = x * scaleX;\n      const scaledY = y * scaleY;\n      const scaledWidth = width * scaleX;\n      const scaledHeight = height * scaleY;\n\n      // Draw rectangle with thicker border\n      context.strokeStyle = `hsl(${index * 137.5 % 360}, 80%, 60%)`;\n      context.lineWidth = 4;\n      context.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);\n\n      // Draw label background with better contrast\n      const labelText = `${label}: ${(confidence * 100).toFixed(0)}%`;\n      const textMetrics = context.measureText(labelText);\n      const textWidth = textMetrics.width;\n      const textHeight = 24;\n\n      // Background with border\n      context.fillStyle = `hsl(${index * 137.5 % 360}, 80%, 20%)`;\n      context.fillRect(scaledX, scaledY - textHeight - 2, textWidth + 12, textHeight + 4);\n\n      // Border\n      context.strokeStyle = `hsl(${index * 137.5 % 360}, 80%, 60%)`;\n      context.lineWidth = 2;\n      context.strokeRect(scaledX, scaledY - textHeight - 2, textWidth + 12, textHeight + 4);\n\n      // Draw label text\n      context.fillStyle = 'white';\n      context.font = 'bold 16px Arial';\n      context.fillText(labelText, scaledX + 6, scaledY - 6);\n    });\n  };\n  const handleDetection = async () => {\n    if (isDetecting) return;\n    setIsDetecting(true);\n    setError(null);\n    try {\n      const photoBlob = await capturePhoto();\n      if (!photoBlob) {\n        throw new Error('Failed to capture photo');\n      }\n      const formData = new FormData();\n      formData.append('file', photoBlob, 'photo.jpg');\n      let response;\n      if (mode === 'serious') {\n        response = await seriousModeDetection(formData);\n      } else {\n        response = await funModeDetection(formData);\n      }\n      setDetectionResults(response);\n\n      // Draw bounding boxes if detections exist\n      if (response.detections && response.detections.length > 0) {\n        setBoundingBoxes(response.detections);\n        setTimeout(() => drawBoundingBoxes(), 100);\n      }\n    } catch (err) {\n      setError(err.message || 'Detection failed. Please try again.');\n      console.error('Detection error:', err);\n    } finally {\n      setIsDetecting(false);\n    }\n  };\n  const handleQuestComplete = async questId => {\n    try {\n      const response = await completeQuest(questId);\n      onQuestComplete(questId);\n      setDetectionResults(prev => ({\n        ...prev,\n        message: response.message\n      }));\n    } catch (err) {\n      setError('Failed to complete quest. Please try again.');\n    }\n  };\n  const handleBetPlaced = async betData => {\n    try {\n      const response = await placeBet({\n        betting_line: betData.line,\n        stake: betData.base_stake,\n        sponsor: betData.sponsor,\n        multiplier: betData.multiplier\n      });\n      onBetPlaced({\n        bet_id: response.bet_id,\n        betting_line: betData.line,\n        stake: betData.base_stake,\n        sponsor: betData.sponsor,\n        multiplier: betData.multiplier,\n        potential_winnings: response.potential_winnings,\n        status: 'active',\n        created_at: new Date().toISOString()\n      });\n      setDetectionResults(prev => ({\n        ...prev,\n        message: response.message\n      }));\n    } catch (err) {\n      setError('Failed to place bet. Please try again.');\n    }\n  };\n  const handleBetResolved = async (betId, won) => {\n    try {\n      const response = await resolveBet(betId, won);\n      setDetectionResults(prev => ({\n        ...prev,\n        message: response.message\n      }));\n    } catch (err) {\n      setError('Failed to resolve bet. Please try again.');\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"h-full flex flex-col bg-black\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex-1 relative h-screen\",\n      children: [/*#__PURE__*/_jsxDEV(\"video\", {\n        ref: videoRef,\n        autoPlay: true,\n        playsInline: true,\n        muted: true,\n        className: \"w-full h-full object-cover\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 305,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"absolute inset-0 w-full h-full object-cover pointer-events-none\",\n        style: {\n          zIndex: 5\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 312,\n        columnNumber: 9\n      }, this), boundingBoxes.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"absolute top-4 right-4 z-20 bg-black bg-opacity-70 rounded-lg p-3\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"text-white text-sm\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"font-bold text-green-400\",\n            children: [\"Objects: \", boundingBoxes.length]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 322,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"text-xs mt-1\",\n            children: boundingBoxes.map((box, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"text-green-300\",\n              children: [box.label, \" (\", (box.confidence * 100).toFixed(0), \"%)\"]\n            }, i, true, {\n              fileName: _jsxFileName,\n              lineNumber: 325,\n              columnNumber: 19\n            }, this))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 323,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 321,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 320,\n        columnNumber: 11\n      }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-500 text-white p-4 rounded-lg max-w-md text-center\",\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 337,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 304,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 302,\n    columnNumber: 5\n  }, this);\n};\n_s(CameraView, \"b7a+rv8TNN74dNGKuenNUyDQ+AI=\");\n_c = CameraView;\nexport default CameraView;\nvar _c;\n$RefreshReg$(_c, \"CameraView\");","map":{"version":3,"names":["React","useRef","useState","useEffect","seriousModeDetection","funModeDetection","completeQuest","placeBet","resolveBet","jsxDEV","_jsxDEV","CameraView","mode","onQuestComplete","onBetPlaced","_s","videoRef","canvasRef","stream","setStream","isDetecting","setIsDetecting","detectionResults","setDetectionResults","error","setError","boundingBoxes","setBoundingBoxes","isRealTimeDetection","setIsRealTimeDetection","detectionInterval","setDetectionInterval","startCamera","getTracks","forEach","track","stop","clearInterval","video","current","handleLoadedMetadata","detections","setTimeout","drawBoundingBoxes","addEventListener","removeEventListener","interval","setInterval","performRealTimeDetection","mediaStream","navigator","mediaDevices","getUserMedia","width","ideal","height","facingMode","srcObject","err","console","capturePhoto","canvas","context","getContext","videoWidth","videoHeight","drawImage","Promise","resolve","toBlob","_response$detections","document","createElement","blob","formData","FormData","append","response","highConfidenceDetections","filter","detection","confidence","length","clearBoundingBoxes","clearRect","index","x","y","label","scaleX","clientWidth","scaleY","clientHeight","scaledX","scaledY","scaledWidth","scaledHeight","strokeStyle","lineWidth","strokeRect","labelText","toFixed","textMetrics","measureText","textWidth","textHeight","fillStyle","fillRect","font","fillText","handleDetection","photoBlob","Error","message","handleQuestComplete","questId","prev","handleBetPlaced","betData","betting_line","line","stake","base_stake","sponsor","multiplier","bet_id","potential_winnings","status","created_at","Date","toISOString","handleBetResolved","betId","won","className","children","ref","autoPlay","playsInline","muted","fileName","_jsxFileName","lineNumber","columnNumber","style","zIndex","map","box","i","_c","$RefreshReg$"],"sources":["/Users/notjackl3/Desktop/HTN2025/frontend/src/components/CameraView.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport { seriousModeDetection, funModeDetection, completeQuest, placeBet, resolveBet } from '../services/api';\n\nconst CameraView = ({ mode, onQuestComplete, onBetPlaced }) => {\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [stream, setStream] = useState(null);\n  const [isDetecting, setIsDetecting] = useState(false);\n  const [detectionResults, setDetectionResults] = useState(null);\n  const [error, setError] = useState(null);\n  const [boundingBoxes, setBoundingBoxes] = useState([]);\n  const [isRealTimeDetection, setIsRealTimeDetection] = useState(true);\n  const [detectionInterval, setDetectionInterval] = useState(null);\n\n  useEffect(() => {\n    startCamera();\n    return () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (detectionInterval) {\n        clearInterval(detectionInterval);\n      }\n    };\n  }, []);\n\n  // Redraw bounding boxes when video loads or resizes\n  useEffect(() => {\n    const video = videoRef.current;\n    if (video) {\n      const handleLoadedMetadata = () => {\n        if (detectionResults?.detections) {\n          setTimeout(() => drawBoundingBoxes(), 100);\n        }\n      };\n      \n      video.addEventListener('loadedmetadata', handleLoadedMetadata);\n      return () => video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n    }\n  }, [detectionResults]);\n\n  // Real-time detection effect\n  useEffect(() => {\n    if (isRealTimeDetection && stream) {\n      const interval = setInterval(() => {\n        performRealTimeDetection();\n      }, 500); // Detect every 500ms for smoother real-time experience\n      \n      setDetectionInterval(interval);\n      \n      return () => {\n        if (interval) {\n          clearInterval(interval);\n        }\n      };\n    } else if (detectionInterval) {\n      clearInterval(detectionInterval);\n      setDetectionInterval(null);\n    }\n  }, [isRealTimeDetection, stream]);\n\n  const startCamera = async () => {\n    try {\n      const mediaStream = await navigator.mediaDevices.getUserMedia({\n        video: { \n          width: { ideal: 1280 },\n          height: { ideal: 720 },\n          facingMode: 'user'\n        }\n      });\n      \n      setStream(mediaStream);\n      if (videoRef.current) {\n        videoRef.current.srcObject = mediaStream;\n        // Start real-time detection immediately\n        setIsRealTimeDetection(true);\n      }\n    } catch (err) {\n      setError('Camera access denied. Please allow camera access to use this feature.');\n      console.error('Camera error:', err);\n    }\n  };\n\n  const capturePhoto = () => {\n    if (!videoRef.current || !canvasRef.current) return null;\n\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    context.drawImage(video, 0, 0);\n\n    return new Promise((resolve) => {\n      canvas.toBlob(resolve, 'image/jpeg', 0.8);\n    });\n  };\n\n  const performRealTimeDetection = async () => {\n    if (!videoRef.current || isDetecting) return;\n\n    try {\n      // Create a canvas to capture video frame\n      const video = videoRef.current;\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      \n      // Set canvas size to match video\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n      \n      // Draw current video frame to canvas\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n      \n      // Convert canvas to blob\n      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));\n      if (!blob) return;\n\n      const formData = new FormData();\n      formData.append('file', blob, 'frame.jpg');\n\n      let response;\n      if (mode === 'serious') {\n        response = await seriousModeDetection(formData);\n      } else {\n        response = await funModeDetection(formData);\n      }\n\n      // Filter detections with 80%+ confidence\n      const highConfidenceDetections = response.detections?.filter(\n        detection => detection.confidence >= 0.8\n      ) || [];\n\n      if (highConfidenceDetections.length > 0) {\n        setBoundingBoxes(highConfidenceDetections);\n        setTimeout(() => drawBoundingBoxes(), 50);\n      } else {\n        // Clear boxes if no high confidence detections\n        setBoundingBoxes([]);\n        clearBoundingBoxes();\n      }\n    } catch (err) {\n      console.error('Real-time detection error:', err);\n    }\n  };\n\n  const clearBoundingBoxes = () => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  const drawBoundingBoxes = () => {\n    if (!videoRef.current || !boundingBoxes.length) return;\n\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n\n    // Set canvas size to match video\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    // Clear previous drawings\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw bounding boxes\n    boundingBoxes.forEach((detection, index) => {\n      const { x, y, width, height, label, confidence } = detection;\n      \n      // Calculate scale factors\n      const scaleX = video.videoWidth / video.clientWidth;\n      const scaleY = video.videoHeight / video.clientHeight;\n      \n      const scaledX = x * scaleX;\n      const scaledY = y * scaleY;\n      const scaledWidth = width * scaleX;\n      const scaledHeight = height * scaleY;\n\n      // Draw rectangle with thicker border\n      context.strokeStyle = `hsl(${(index * 137.5) % 360}, 80%, 60%)`;\n      context.lineWidth = 4;\n      context.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);\n\n      // Draw label background with better contrast\n      const labelText = `${label}: ${(confidence * 100).toFixed(0)}%`;\n      const textMetrics = context.measureText(labelText);\n      const textWidth = textMetrics.width;\n      const textHeight = 24;\n\n      // Background with border\n      context.fillStyle = `hsl(${(index * 137.5) % 360}, 80%, 20%)`;\n      context.fillRect(scaledX, scaledY - textHeight - 2, textWidth + 12, textHeight + 4);\n      \n      // Border\n      context.strokeStyle = `hsl(${(index * 137.5) % 360}, 80%, 60%)`;\n      context.lineWidth = 2;\n      context.strokeRect(scaledX, scaledY - textHeight - 2, textWidth + 12, textHeight + 4);\n\n      // Draw label text\n      context.fillStyle = 'white';\n      context.font = 'bold 16px Arial';\n      context.fillText(labelText, scaledX + 6, scaledY - 6);\n    });\n  };\n\n  const handleDetection = async () => {\n    if (isDetecting) return;\n\n    setIsDetecting(true);\n    setError(null);\n\n    try {\n      const photoBlob = await capturePhoto();\n      if (!photoBlob) {\n        throw new Error('Failed to capture photo');\n      }\n\n      const formData = new FormData();\n      formData.append('file', photoBlob, 'photo.jpg');\n\n      let response;\n      if (mode === 'serious') {\n        response = await seriousModeDetection(formData);\n      } else {\n        response = await funModeDetection(formData);\n      }\n\n      setDetectionResults(response);\n      \n      // Draw bounding boxes if detections exist\n      if (response.detections && response.detections.length > 0) {\n        setBoundingBoxes(response.detections);\n        setTimeout(() => drawBoundingBoxes(), 100);\n      }\n    } catch (err) {\n      setError(err.message || 'Detection failed. Please try again.');\n      console.error('Detection error:', err);\n    } finally {\n      setIsDetecting(false);\n    }\n  };\n\n  const handleQuestComplete = async (questId) => {\n    try {\n      const response = await completeQuest(questId);\n      onQuestComplete(questId);\n      setDetectionResults(prev => ({\n        ...prev,\n        message: response.message\n      }));\n    } catch (err) {\n      setError('Failed to complete quest. Please try again.');\n    }\n  };\n\n  const handleBetPlaced = async (betData) => {\n    try {\n      const response = await placeBet({\n        betting_line: betData.line,\n        stake: betData.base_stake,\n        sponsor: betData.sponsor,\n        multiplier: betData.multiplier\n      });\n      \n      onBetPlaced({\n        bet_id: response.bet_id,\n        betting_line: betData.line,\n        stake: betData.base_stake,\n        sponsor: betData.sponsor,\n        multiplier: betData.multiplier,\n        potential_winnings: response.potential_winnings,\n        status: 'active',\n        created_at: new Date().toISOString()\n      });\n      \n      setDetectionResults(prev => ({\n        ...prev,\n        message: response.message\n      }));\n    } catch (err) {\n      setError('Failed to place bet. Please try again.');\n    }\n  };\n\n  const handleBetResolved = async (betId, won) => {\n    try {\n      const response = await resolveBet(betId, won);\n      setDetectionResults(prev => ({\n        ...prev,\n        message: response.message\n      }));\n    } catch (err) {\n      setError('Failed to resolve bet. Please try again.');\n    }\n  };\n\n  return (\n    <div className=\"h-full flex flex-col bg-black\">\n      {/* Camera View - Full Screen */}\n      <div className=\"flex-1 relative h-screen\">\n        <video\n          ref={videoRef}\n          autoPlay\n          playsInline\n          muted\n          className=\"w-full h-full object-cover\"\n        />\n        <canvas\n          ref={canvasRef}\n          className=\"absolute inset-0 w-full h-full object-cover pointer-events-none\"\n          style={{ zIndex: 5 }}\n        />\n        \n        {/* Minimal Status - Only show when objects are detected */}\n        {boundingBoxes.length > 0 && (\n          <div className=\"absolute top-4 right-4 z-20 bg-black bg-opacity-70 rounded-lg p-3\">\n            <div className=\"text-white text-sm\">\n              <div className=\"font-bold text-green-400\">Objects: {boundingBoxes.length}</div>\n              <div className=\"text-xs mt-1\">\n                {boundingBoxes.map((box, i) => (\n                  <div key={i} className=\"text-green-300\">\n                    {box.label} ({(box.confidence * 100).toFixed(0)}%)\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        )}\n\n\n        {/* Error Message */}\n        {error && (\n          <div className=\"absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-500 text-white p-4 rounded-lg max-w-md text-center\">\n            {error}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default CameraView;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}